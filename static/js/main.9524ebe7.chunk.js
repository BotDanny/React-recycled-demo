(this["webpackJsonpreact-recycled-demo"]=this["webpackJsonpreact-recycled-demo"]||[]).push([[0],{267:function(e,n,t){"use strict";t.r(n);var o=t(0),a=t.n(o),i=t(8),r=t.n(i),l=(t(72),t(5)),d=(t(73),t(21)),s=t(23),c=t(22);function u(e){for(var n=0,t=[],o=e.length,a=0;a<o;a++)t[a]=0===a?0:n,n+=e[a];return t}function h(e,n){for(var t=e.length,o=0,a={},i=0;i<t;i++){var r=Math.min(o+e[i],n);a[i]=[o,r],o=r}return a}function m(e,n){return n?"".concat(e," ").concat(n):e}function f(e){if(-1===e||void 0===e)throw Error("Invalid input to ScrollTo, make sure your input data index or row is correct")}function w(e,n){for(var t=0,o=e.length-1;t<=o;){var a=Math.floor((t+o)/2);e[a]<=n?t=a+1:o=a-1}return t}function p(e,n){for(var t=0,o=e.length-1;t<=o;){var a=Math.floor((t+o)/2);e[a]<n?t=a+1:o=a-1}return t}var g=t(37),v=t(39),x={firstRenderedRowIndex:-1,firstRenderedDataIndex:-1,lastRenderedRowIndex:-1,lastRenderedDataIndex:-1,lastRowIndex:-1},R={firstVisibleRowIndex:-1,firstVisibleDataIndex:-1,lastVisibleRowIndex:-1,lastVisibleDataIndex:-1,lastRowIndex:-1},b=t(1),I=function(e){Object(s.a)(t,e);var n=Object(c.a)(t);function t(e){var o;return Object(d.a)(this,t),(o=n.call(this,e)).prevScroll=void 0,o.prevLastVisibleRow=void 0,o.prevLastRenderedRow=void 0,o.listWindowRef=void 0,o.rowHeights=void 0,o.rowPositions=void 0,o.rowToDataIndexMap=void 0,o.totalNumOfRenderedRows=void 0,o.initialArrayTemplate=void 0,o.totalRows=void 0,o.fullHeight=void 0,o.timeOut=void 0,o.windowHeight=void 0,o.numOfInvisibleRowOnEachDirection=void 0,o.onListWillRecycle=function(e,n,t){var a=o.props,i=a.useScrollingIndicator,r=a.onRenderedRowChange;if(i&&(o.setState({scrollState:n}),o._debounceScrollState()),r){if(0===o.totalNumOfRenderedRows)return void r(x);var l=e[o.mod(t-1)];if(l===o.prevLastRenderedRow)return;var d=e[t];r({firstRenderedRowIndex:d,firstRenderedDataIndex:o.rowToDataIndexMap[d][0],lastRenderedRowIndex:l,lastRenderedDataIndex:o.rowToDataIndexMap[l][1]-1,lastRowIndex:o.totalRows-1}),o.prevLastRenderedRow=l}},o.onScrollChange=function(e){var n=o.props.onVisibleRowChange;if(n){if(0===o.totalNumOfRenderedRows)return n(R),void(o.prevLastVisibleRow=-1);var t=o.getBottomViewportRowIndex(e+o.windowHeight);if(o.fullHeight<o.windowHeight&&(t=o.getBottomViewportRowIndex(e+o.fullHeight)),t!==o.prevLastVisibleRow){var a=o.getTopViewportRowIndex(e);n({firstVisibleRowIndex:a,firstVisibleDataIndex:o.rowToDataIndexMap[a][0],lastVisibleRowIndex:t,lastVisibleDataIndex:o.rowToDataIndexMap[t][1]-1,lastRowIndex:o.totalRows-1}),o.prevLastVisibleRow=t}}},o.recycle=function(e){var n=o.state,t=n.renderedRowIndex,a=n.topRenderedRowRelativeIndex,i=n.scrollState,r=!(e-o.prevScroll>0);o.prevScroll=e,o.onScrollChange(e);var l=0;if(r){l=t[a]-Math.max(o.getTopViewportRowIndex(e)-o.numOfInvisibleRowOnEachDirection,0)}else{var d=t[o.mod(a-1)],s=e+o.windowHeight;l=Math.min(o.getBottomViewportRowIndex(s)+o.numOfInvisibleRowOnEachDirection,o.totalRows-1)-d}if(l>0){for(var c=Object(g.a)(t),u=Object(g.a)(i),h=0;h<l;){var m=o.mod(a+(r?-h-1:h));c[m]+=r?-o.totalNumOfRenderedRows:o.totalNumOfRenderedRows,u[m]=!0,h++}var f=o.mod(a+(r?-l:l));o.onListWillRecycle(c,u,f),o.setState({renderedRowIndex:c,topRenderedRowRelativeIndex:f})}},o.resetList=function(){var e=o.totalNumOfRenderedRows-1,n=o.getResetViewportBottom(),t=Math.min(o.getBottomViewportRowIndex(n)+o.numOfInvisibleRowOnEachDirection,o.totalRows-1)-e,a=o.initialArrayTemplate.map((function(e,n){return n})),i=o.initialArrayTemplate.map((function(){return!1})),r=0;if(t>0){for(var l=0;l<t;){var d=o.mod(l);a[d]+=o.totalNumOfRenderedRows,i[d]=!0,l++}r=o.mod(t)}o.onListWillRecycle(a,i,r),o.onScrollChange(o.prevScroll),o.setState({renderedRowIndex:a,topRenderedRowRelativeIndex:r})},o.onScroll=function(e){o.recycle(e.currentTarget.scrollTop)},o.scrollToDataIndex=function(e){var n=Object.values(o.rowToDataIndexMap).findIndex((function(n){return e>=n[0]&&e<n[1]}));f(n);var t=o.rowPositions[n];o.manualScroll(t)},o.scrollToRow=function(e){var n=o.rowPositions[e];f(n),o.manualScroll(n)},o.scrollTo=function(e){o.manualScroll(e)},o.manualScroll=function(e){o.listWindowRef.current&&(o.listWindowRef.current.scrollTop=e)},o.mod=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.totalNumOfRenderedRows;return(e%n+n)%n},o.getResetViewportBottom=function(){return o.prevScroll+o.windowHeight},o._debounceScrollState=function(){clearTimeout(o.timeOut),o.timeOut=setTimeout((function(){o.setState({scrollState:o.initialArrayTemplate.map((function(){return!1}))})}),o.props.scrollInterval||250)},o.prevScroll=0,o.prevLastVisibleRow=-1,o.prevLastRenderedRow=-1,o}return Object(v.a)(t,[{key:"componentDidMount",value:function(){var e=this.props.initalScrollTop;e&&this.manualScroll(e)}},{key:"componentDidUpdate",value:function(e){if(this.shouldResetList(e)){var n=this.initializeProperties(),t=n.rowToDataIndexMap,o=n.rowPositions,a=n.totalRows,i=n.initialArrayTemplate,r=n.fullHeight,l=n.totalNumOfRenderedRows,d=n.numOfInvisibleRowOnEachDirection,s=n.windowHeight,c=n.rowHeights;this.rowToDataIndexMap=t,this.rowPositions=o,this.totalRows=a,this.initialArrayTemplate=i,this.fullHeight=r,this.totalNumOfRenderedRows=l,this.numOfInvisibleRowOnEachDirection=d,this.rowHeights=c,this.windowHeight=s,this.resetList()}}},{key:"render",value:function(){var e=this,n=this.props,t=n.listTagName,o=n.listClassName,a=n.listWindowClassName,i=n.data,r=n.width,l=n.rowComponent,d=(n.rowTagName,n.rowClassName,this.state),s=d.renderedRowIndex,c=d.scrollState,u=t||"div",h=l;return Object(b.jsx)("div",{className:m("react-recycled-list-window",a),style:{height:this.windowHeight,overflowY:"auto",width:r||"100%"},onScroll:this.onScroll,ref:this.listWindowRef,children:Object(b.jsx)(u,{className:m("react-recycled-list",o),style:{height:this.fullHeight,position:"relative"},children:s.map((function(n,t){var o=e.rowToDataIndexMap[n],a=o[0],r=o[1],l={position:"absolute",top:e.rowPositions[n],height:e.rowHeights[n],width:"100%",boxSizing:"border-box"};return Object(b.jsx)(h,{data:i,dataIndex:a,dataEndIndex:r,row:n,column:r-a,isScrolling:c[t],style:l},t)}))})})}}]),t}(a.a.PureComponent),y=function(e){Object(s.a)(t,e);var n=Object(c.a)(t);function t(e){var o;Object(d.a)(this,t),(o=n.call(this,e)).rowPositions=void 0,o.rowHeights=void 0,o.rowToDataIndexMap=void 0,o.fullHeight=void 0,o.windowHeight=void 0,o.initialArrayTemplate=void 0,o.totalNumOfRenderedRows=void 0,o.numOfInvisibleRowOnEachDirection=void 0,o.totalRows=void 0,o.timeOut=void 0,o.listWindowRef=void 0,o.initializeProperties=function(){var e=o.props,n=e.rowHeight,t=e.column,a=e.rowColumns,i=e.data,r=e.height,l=e.additionalRenderedRow;if(a&&a.reduce((function(e,n){return e+n}),0)!==i.length)throw Error("The total number of data item calculated from rowColumns does not match the length of your input data");var d=a||(t?Array(Math.ceil(i.length/t)).fill(t):Array(i.length).fill(1)),s=d.map((function(){return n})),c=h(d,i.length),m=u(s),f=s.length,w=Math.ceil(r/n),p=l||Math.floor(w/2),g=w+2*p;return g>f&&(g=f),{rowToDataIndexMap:c,rowPositions:m,totalRows:f,initialArrayTemplate:Array(g).fill(null),fullHeight:s.reduce((function(e,n){return e+n}),0),totalNumOfRenderedRows:g,numOfInvisibleRowOnEachDirection:p,rowHeights:s,windowHeight:r}},o.shouldResetList=function(e){var n=o.props;if(e===n)return!1;var t=n.rowHeight,a=n.column,i=n.rowColumns,r=n.height,l=n.data,d=n.additionalRenderedRow;return e.rowHeight!==t||e.column!==a||e.rowColumns!==i||e.height!==r||e.data!==l||e.additionalRenderedRow!==d},o.getTopViewportRowIndex=function(e){return Math.floor(e/o.props.rowHeight)},o.getBottomViewportRowIndex=function(e){var n=e/o.props.rowHeight;return Number.isInteger(n)?n-=1:n=Math.floor(n),n};var i=o.initializeProperties(),r=i.rowToDataIndexMap,l=i.rowPositions,s=i.totalRows,c=i.initialArrayTemplate,m=i.fullHeight,f=i.totalNumOfRenderedRows,w=i.numOfInvisibleRowOnEachDirection,p=i.rowHeights,g=i.windowHeight;o.rowToDataIndexMap=r,o.rowPositions=l,o.totalRows=s,o.initialArrayTemplate=c,o.fullHeight=m,o.totalNumOfRenderedRows=f,o.numOfInvisibleRowOnEachDirection=w,o.rowHeights=p,o.windowHeight=g,o.listWindowRef=a.a.createRef();var v=o.initialArrayTemplate.map((function(e,n){return n})),x=o.initialArrayTemplate.map((function(){return!1}));return o.onListWillRecycle(v,x,0),o.onScrollChange(0),o.state={renderedRowIndex:v,scrollState:x,topRenderedRowRelativeIndex:0},o}return t}(I),j=function(e){Object(s.a)(t,e);var n=Object(c.a)(t);function t(e){var o;Object(d.a)(this,t),(o=n.call(this,e)).rowPositions=void 0,o.rowHeights=void 0,o.rowToDataIndexMap=void 0,o.fullHeight=void 0,o.windowHeight=void 0,o.initialArrayTemplate=void 0,o.totalNumOfRenderedRows=void 0,o.numOfInvisibleRowOnEachDirection=void 0,o.totalRows=void 0,o.timeOut=void 0,o.listWindowRef=void 0,o.initializeProperties=function(){var e=o.props,n=e.rowHeight,t=e.rowHeights,a=e.column,i=e.rowColumns,r=e.data,l=e.height,d=e.additionalRenderedRow;if(i){if(i.reduce((function(e,n){return e+n}),0)!==r.length)throw Error("The total number of data item calculated from rowColumns does not match the length of your input data");if(i.length!==t.length)throw Error("The number of rows provided from rowHeights does not match the number of rows provided from rowColumns")}else if(a){if(Math.ceil(r.length/a)!==t.length)throw Error("The number of rows provided from rowHeights does not match the number of rows calculated from column")}else if(t.length!==r.length)throw Error("The number of rows provided from rowHeights does not match the number of rows calculated from your input data");var s=h(i||(a?Array(t.length).fill(a):Array(t.length).fill(1)),r.length),c=u(t),m=t.length,f=d||1,w=Math.ceil(l/n)+2*f;return w>m&&(w=m),{rowToDataIndexMap:s,rowPositions:c,totalRows:m,initialArrayTemplate:Array(w).fill(null),fullHeight:t.reduce((function(e,n){return e+n}),0),totalNumOfRenderedRows:w,numOfInvisibleRowOnEachDirection:f,rowHeights:t,windowHeight:l}},o.shouldResetList=function(e){var n=o.props;if(e===n)return!1;var t=n.rowHeight,a=n.rowHeights,i=n.column,r=n.rowColumns,l=n.height,d=n.data,s=n.additionalRenderedRow;return e.rowHeight!==t||e.rowHeights!==a||e.column!==i||e.rowColumns!==r||e.height!==l||e.data!==d||e.additionalRenderedRow!==s},o.getTopViewportRowIndex=function(e){return w(o.rowPositions,e)-1},o.getBottomViewportRowIndex=function(e){return p(o.rowPositions,e)-1};var i=o.initializeProperties(),r=i.rowToDataIndexMap,l=i.rowPositions,s=i.totalRows,c=i.initialArrayTemplate,m=i.fullHeight,f=i.totalNumOfRenderedRows,g=i.numOfInvisibleRowOnEachDirection,v=i.rowHeights,x=i.windowHeight;o.rowToDataIndexMap=r,o.rowPositions=l,o.totalRows=s,o.initialArrayTemplate=c,o.fullHeight=m,o.totalNumOfRenderedRows=f,o.numOfInvisibleRowOnEachDirection=g,o.rowHeights=v,o.windowHeight=x,o.listWindowRef=a.a.createRef();var R=o.initialArrayTemplate.map((function(e,n){return n})),b=o.initialArrayTemplate.map((function(){return!1}));return o.onListWillRecycle(R,b,0),o.onScrollChange(0),o.state={renderedRowIndex:R,scrollState:b,topRenderedRowRelativeIndex:0},o}return t}(I),O=(t(294),t(46)),D=t(40);function S(e){var n=e.render,t=e.className,o=e.debounceResize,i=e.debounceInterval,r=e.serverSideHeight,d=Object(D.a)({refreshMode:o?"debounce":void 0,refreshRate:i||100}),s=d.width,c=d.height,u=d.ref,h=a.a.useState(!1),f=Object(l.a)(h,2),w=f[0],p=f[1];return a.a.useEffect((function(){void 0!==r&&p(!0)})),Object(b.jsx)("div",{className:m("react-recycled-responsive-container",t),ref:u,style:{height:"100%",width:"100%"},children:n({width:s||0,height:c||!w&&r||0})})}var L=function(e){Object(s.a)(t,e);var n=Object(c.a)(t);function t(e){var o;Object(d.a)(this,t),(o=n.call(this,e)).rowPositions=void 0,o.rowHeights=void 0,o.rowToDataIndexMap=void 0,o.fullHeight=void 0,o.windowHeight=void 0,o.initialArrayTemplate=void 0,o.totalNumOfRenderedRows=void 0,o.numOfInvisibleRowOnEachDirection=void 0,o.totalRows=void 0,o.timeOut=void 0,o.initialScrolling=void 0,o.fullListRef=void 0,o.scrollListener=void 0,o.listWindowRef=void 0,o.initializeProperties=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=o.props,t=n.rowHeight,a=n.column,i=n.rowColumns,r=n.data,l=n.additionalRenderedRow,d=n.serverWindowHeight,s=n.scrollRef,c=n.rootMarginTop,m=void 0===c?0:c,f=n.rootMarginBottom,w=void 0===f?0:f;if(i&&i.reduce((function(e,n){return e+n}),0)!==r.length)throw Error("The total number of data item calculated from rowColumns does not match the length of your input data");var p,g=0;e&&void 0!==d?g=d:"scrollRef"in o.props?(null===s||void 0===s?void 0:s.current)?(g=parseInt(window.getComputedStyle(s.current).height),p=s.current):g=0:(g=window.innerHeight,p=window),g=Math.max(0,g-m-w);var v=i||(a?Array(Math.ceil(r.length/a)).fill(a):Array(r.length).fill(1)),x=v.map((function(){return t})),R=h(v,r.length),b=u(x),I=x.length,y=Math.ceil(g/t),j=l||y?1:0,O=y+2*j;O>I&&(O=I);var D=Array(O).fill(null),S=x.reduce((function(e,n){return e+n}),0);return{rowToDataIndexMap:R,rowPositions:b,totalRows:I,initialArrayTemplate:D,fullHeight:S,totalNumOfRenderedRows:O,numOfInvisibleRowOnEachDirection:j,rowHeights:x,windowHeight:g,scrollListener:p}},o.attachScrollListener=function(){o.scrollListener&&(o.scrollListener.removeEventListener("scroll",o.onScroll),o.scrollListener.addEventListener("scroll",o.onScroll))},o.getScrollTop=function(){var e=o.props.rootMarginTop,n=void 0===e?0:e,t=o.fullListRef.current;if(!t)return window.scrollY;var a=o.scrollListener===window?0:o.scrollListener.getBoundingClientRect().top;return-(t.getBoundingClientRect().top-a-n)},o.onScroll=function(){if(o.fullListRef){var e=o.getScrollTop();o.recycle(e)}},o.manualScroll=function(e){var n=o.props.rootMarginTop,t=void 0===n?0:n;if(o.scrollListener){var a=o.fullListRef.current;if(o.scrollListener===window){var i=a.getBoundingClientRect().top+window.scrollY;window.scrollTo({top:i+e-t})}else{var r=o.scrollListener,l=a.getBoundingClientRect().top-r.getBoundingClientRect().top;r.scrollTop=l+e-t}}},o.shouldResetList=function(e){var n=o.props,t=n.rowHeight,a=n.column,i=n.rowColumns,r=n.windowHeight,l=n.data,d=n.additionalRenderedRow,s=n.scrollRef,c=n.rootMarginBottom,u=n.rootMarginTop;return e.data!==l||e.windowHeight!==r||s&&s.current!==o.scrollListener||e.rowHeight!==t||e.column!==a||e.rowColumns!==i||e.additionalRenderedRow!==d||e.rootMarginBottom!==c||e.rootMarginTop!==u},o.resetListAndRef=function(){var e=o.initializeProperties(),n=e.rowToDataIndexMap,t=e.rowPositions,a=e.totalRows,i=e.initialArrayTemplate,r=e.fullHeight,l=e.totalNumOfRenderedRows,d=e.numOfInvisibleRowOnEachDirection,s=e.rowHeights,c=e.windowHeight,u=e.scrollListener,h=o.props.scrollRef;o.rowToDataIndexMap=n,o.rowPositions=t,o.totalRows=a,o.initialArrayTemplate=i,o.fullHeight=r,o.totalNumOfRenderedRows=l,o.numOfInvisibleRowOnEachDirection=d,o.rowHeights=s,o.windowHeight=c,h&&h.current!==o.scrollListener&&(o.scrollListener=u,o.attachScrollListener()),o.resetList()},o.setCustomScrollRef=function(){o.resetListAndRef()},o.getTopViewportRowIndex=function(e){return Math.max(Math.floor(e/o.props.rowHeight),0)},o.getBottomViewportRowIndex=function(e){var n=e/o.props.rowHeight;return Number.isInteger(n)?n-=1:n=Math.floor(n),Math.min(n,o.totalRows-1)},o.getResetViewportBottom=function(){if(o.fullListRef){var e=o.props,n=e.rootMarginBottom,t=void 0===n?0:n,a=e.rootMarginTop,i=void 0===a?0:a;return o.getScrollTop()+(o.windowHeight+i+t)-t}return o.prevScroll+o.windowHeight};var i=o.initializeProperties(!0),r=i.rowToDataIndexMap,l=i.rowPositions,s=i.totalRows,c=i.initialArrayTemplate,m=i.fullHeight,f=i.totalNumOfRenderedRows,w=i.numOfInvisibleRowOnEachDirection,p=i.rowHeights,g=i.windowHeight,v=i.scrollListener;return o.fullListRef=a.a.createRef(),o.listWindowRef=null,o.rowToDataIndexMap=r,o.rowPositions=l,o.totalRows=s,o.initialArrayTemplate=c,o.fullHeight=m,o.totalNumOfRenderedRows=f,o.numOfInvisibleRowOnEachDirection=w,o.rowHeights=p,o.windowHeight=g,o.scrollListener=v,o.initialScrolling=!1,o.state={renderedRowIndex:o.initialArrayTemplate.map((function(e,n){return n})),scrollState:o.initialArrayTemplate.map((function(){return!1})),topRenderedRowRelativeIndex:0},o}return Object(v.a)(t,[{key:"componentDidMount",value:function(){this.attachScrollListener();var e=this.props.initalScrollTop;e&&this.manualScroll(e)}},{key:"componentWillUnmount",value:function(){this.scrollListener&&this.scrollListener.removeEventListener("scroll",this.onScroll)}},{key:"componentDidUpdate",value:function(e){this.shouldResetList(e)&&this.resetListAndRef()}},{key:"render",value:function(){var e=this,n=this.props,t=n.listTagName,o=n.listClassName,a=n.data,i=n.width,r=n.rowComponent,l=n.rowTagName,d=n.rowClassName,s=this.state,c=s.renderedRowIndex,u=s.scrollState;console.log("render");var h=t||"div",f=l||"div",w=r;return Object(b.jsx)(h,{className:m("react-recycled-list",o),style:{height:this.fullHeight,position:"relative",width:i},ref:this.fullListRef,children:c.map((function(n,t){var o=e.rowToDataIndexMap[n],i=o[0],r=o[1];return Object(b.jsx)(f,{style:{position:"absolute",top:e.rowPositions[n],height:e.rowHeights[n],width:"100%",boxSizing:"border-box"},className:m("react-recycled-row",d),children:Object(b.jsx)(w,{data:a,dataIndex:i,dataEndIndex:r,row:n,column:r-i,isScrolling:u[t]})},t)}))})}}]),t}(I),H=t(9),C=(t(57),t(295)),T=t(49),P=t(291),A=t(292),N=t(296),M=t(293),E=t(29),F=t(30),V=t.n(F);function k(e){var n=e.code,t=e.Demo;return Object(b.jsxs)(b.Fragment,{children:[Object(b.jsx)("div",{className:"demo-section half-section",children:Object(b.jsx)(t,{})}),Object(b.jsx)("div",{className:"code-section half-section",children:Object(b.jsx)("div",{className:"code-wrapper",children:Object(b.jsx)(V.a,{language:"js",children:n})})})]})}function W(e,n){return Math.floor(Math.random()*(n-e+1))+e}function z(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)(y,{height:500,rowComponent:B,data:e,rowHeight:100})}var B=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=(e.index,e.style),i=n[t];return a.a.useEffect((function(){return console.log("render"),function(){console.log("unmount")}}),[]),Object(b.jsx)("div",{style:o,className:"react-recycled-row",children:i},0)})),_='import { FixedList } from "react-recycled-list";\n\nfunction SimpleListDemo() {\n\n  const data = Array(1000).fill(null).map((_, index) => `index ${index}`);\n\n  return <FixedList height={500} rowComponent={Row} data={data} rowHeight={100}/>\n}\n\n// Use React.memo or React pure component to prevent unncessary render\nconst Row = React.memo(function (props) {\n  // the data here is the same data that is passed into the FixedList\n  const { data, dataIndex } = props;\n\n  // Note, the css you see in the demo above is not defined here, check the code sandbox for more\n\n  const value = data[dataIndex];\n  return <div>{value}</div>;\n})';function $(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)(y,{height:300,rowComponent:Y,data:e,rowHeight:100,column:4})}var Y=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.dataEndIndex,a=n.slice(t,o),i={width:"25%",textAlign:"center"};return Object(b.jsx)("div",{style:{height:"100%",width:"100%",display:"flex",alignItems:"center"},children:a.map((function(e){return Object(b.jsx)("div",{style:i,children:e})}))},t)})),U='import { FixedList } from "react-recycled-list";\n\nfunction SimpleGridDemo() {\n    const data = Array(1000).fill(null).map((_, index) => `item ${index}`);\n    return <FixedList height={300} rowComponent={Row} data={data} rowHeight={100} column={4} />\n}\n\nconst Row = React.memo(function (props) {\n    const { data, dataIndex: dataStartIndex, dataEndIndex } = props;\n\n    // You are given the start and end index of the data in this row. You style and arrange the columns yourself\n    // Note the data item at dataEndIndex is not included in the row. If dataIndex = 0 and dataEndIndex = 3 then the data in this row is 0, 1 and 2\n\n    const rowData = data.slice(dataStartIndex, dataEndIndex);\n    // Note you don\'t have to use in-line styling, you can style it however you want\n    const rowStyle = {\n        height: "100%",\n        width: "100%",\n        display: "flex",\n        alignItems: "center",\n    };\n    const columnStyle = {\n        width: "25%",\n        textAlign: "center",\n    };\n    return (\n        <div key={dataIndex} style={rowStyle}>\n                            {rowData.map((item) => <div style={columnStyle} key={item}>{item}</div>)}\n                 </div>\n    )\n});';function q(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)})),n=e.map((function(e,n){return W(60,140)}));return Object(b.jsx)(j,{height:400,rowComponent:G,data:e,rowHeight:100,rowHeights:n})}var G=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=n[t];return Object(b.jsx)("div",{style:{textAlign:"center"},children:o},t)})),J='import { VariableList } from "react-recycled-list";\n\nfunction VariableRowHeightDemo() {\n    const data = Array(1000).fill(null).map((_, index) => `item ${index}`);\n\n    // You define the height of each row. In this case, each row has random height between 60 and 140\n    // Note the length of this array must match the total amount of rows in the list/grid\n\n    const rowHeights = data.map((_, index) => randInt(60, 140));\n    \n    // The rowHeight prop here is an estimate(average) of the height of each row\n\n    return <VariableList height={350} rowComponent={Row} data={data} rowHeight={100} rowHeights={rowHeights}/>;\n}\n  \nconst Row = React.memo(function (props) {\n    const { data, dataIndex } = props;\n    const value = data[dataIndex];\n\n    return <div key={dataIndex}>{value}</div>\n});';function K(){var e=Array(300).fill(null).map((function(){return W(1,4)})),n=e.reduce((function(e,n){return n+e}),0),t=Array(n).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)(y,{height:400,rowComponent:Q,data:t,rowHeight:100,rowColumns:e})}var Q=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.dataEndIndex,a=e.column,i=n.slice(t,o),r={width:{1:"100%",2:"50%",3:"33.33%",4:"25%"}[a],textAlign:"center"};return Object(b.jsx)("div",{style:{height:"100%",width:"100%",display:"flex",alignItems:"center"},children:i.map((function(e){return Object(b.jsx)("div",{style:r,children:e})}))},t)})),X='import { FixedList } from "react-recycled-list";\n\nfunction VariableColumnDemo() {\n\n    // Define 300 rows of data, each row has a random number of column between 1 and 4\n\n    const columnsInEachRow = Array(300).fill(null).map(() => randInt(1, 4));\n\n    // Calculate the total amount of items/columns in the list\n\n    const totalNumberOfItems = columnsInEachRow.reduce((acc, column) => column + acc, 0);\n\n    // Define the data\n\n    const data = Array(totalNumberOfItems).fill(null).map((_, index) => `item ${index}`);\n\n    // It is up to you to define your data and rowColumns, but the total number of columns from rowColumn must be equal to the length of data\n\n    return <FixedList height={400} rowComponent={Row} data={data} rowHeight={100} rowColumns={columnsInEachRow} />\n}\n\nconst Row = React.memo(function (props) {\n\n    // column is the number of column in current row. It can also be calculated as dataEndIndex - dataIndex\n    \n    const { data, dataIndex: dataStartIndex, dataEndIndex, column } = props;\n    const rowData = data.slice(dataStartIndex, dataEndIndex);\n\n    const rowStyle = {\n        height: "100%",\n        width: "100%",\n        display: "flex",\n        alignItems: "center",\n    };\n\n    const widthMap = {\n        1: "100%",\n        2: "50%",\n        3: "33.33%",\n        4: "25%"\n    }\n\n    const columnStyle = {\n        width: widthMap[column],\n        textAlign: "center",\n    };\n    return (\n        <div key={dataIndex} style={rowStyle}>\n                            {rowData.map((item) => <div style={columnStyle} key={item}>{item}</div>)}\n                 </div>\n    )\n});';function Z(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)(L,{rowComponent:ee,data:e,rowHeight:100})}var ee=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=n[t];return Object(b.jsx)("div",{style:{textAlign:"center"},children:o},t)})),ne='import { FullWindowFixedList, FullWindowVariableList } from "react-recycled-list";\n\n// Important! FullWindowFixedList and FullWindowVariableList are not responsive by default!\n// You must wrap in it the responsive container to make it responsive\n\nfunction FullWindowDemo() {\n\n    const data = Array(1000).fill(null).map((_, index) => `index ${index}`);\n\n    // FullWindowFixedList is essentially the same as FixedList but without the height prop\n    // FullWindowVariableList is essentially the same as VariableList but without the height prop\n\n    return <FullWindowFixedList rowComponent={Row} data={data} rowHeight={100} />\n}\n\n// Use React.memo or React pure component to prevent unncessary render\nconst Row = React.memo(function (props) {\n    // the data here is the same data that is passed into the FixedList\n    const { data, dataIndex } = props;\n\n    const value = data[dataIndex];\n    return <div>{value}</div>;\n})';function te(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)})),n=function(e){for(var n=[],t=[],o=0,a=0;o<e;a++){n[a]=W(60,140);var i=W(1,4),r=o+i;t[a]=r>e?e-o:i,o=r}return[n,t]}(e.length),t=Object(l.a)(n,2),o=t[0],a=t[1];return Object(b.jsx)(j,{height:400,rowComponent:oe,data:e,rowHeight:100,rowColumns:a,rowHeights:o})}var oe=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.dataEndIndex,a=e.column,i=n.slice(t,o),r={width:{1:"100%",2:"50%",3:"33.33%",4:"25%"}[a],textAlign:"center"};return Object(b.jsx)("div",{style:{height:"100%",width:"100%",display:"flex",alignItems:"center"},children:i.map((function(e){return Object(b.jsx)("div",{style:r,children:e})}))},t)})),ae='import { VariableList } from "react-recycled-list";\n\n// Function for generating randow row heights and columns\n// Each row will have height between 60 and 140 px and column between 1 and 4\nfunction generateRamdomRowHeightAndColumn(dataLength: number) {\n    const heights: number[] = [];\n    const columns: number[] = [];\n    let nextDataIndex = 0;\n    for (let i = 0; nextDataIndex < dataLength; i++) {\n      heights[i] = randInt(60, 140);\n      const column = randInt(1, 4);\n      const tempNextDataIndex = nextDataIndex + column;\n      columns[i] =\n        tempNextDataIndex > dataLength ? dataLength - nextDataIndex : column;\n      nextDataIndex = tempNextDataIndex;\n    }\n  \n    return [heights, columns];\n}\n  \nfunction VariableRowHeightColumnDemo() {\n    // For demo purposes I used a random generator. You can however define it whatever you want it to be.\n    // The key takeaway is the length of rowHeights must equal to the length of rowColumns\n    // And the total number of column calculated from rowColumns must be equal to the length of data\n    const [rowHeights, rowColumns] = generateRamdomRowHeightAndColumn(data.length)\n  \n    const data = Array(totalNumberOfItems).fill(null).map((_, index) => `item ${index}`);\n  \n    return <VariableList height={400} rowComponent={Row} data={data} rowHeight={100} rowColumns={rowColumns} rowHeights={rowHeights}/>\n}\n  \nconst Row = React.memo(function (props) {\n    const { data, dataIndex: dataStartIndex, dataEndIndex, column } = props;\n    const rowData = data.slice(dataStartIndex, dataEndIndex);\n  \n    const rowStyle = {\n        height: "100%",\n        width: "100%",\n        display: "flex",\n        alignItems: "center",\n    };\n  \n    const widthMap = {\n        1: "100%",\n        2: "50%",\n        3: "33.33%",\n        4: "25%"\n    }\n  \n    const columnStyle = {\n        width: widthMap[column],\n        textAlign: "center",\n    };\n\n    return (\n        <div key={dataIndex} style={rowStyle}>\n                            {rowData.map((item) => <div style={columnStyle} key={item}>{item}</div>)}\n                 </div>\n    )\n});';function ie(){var e=a.a.useRef(),n=a.a.useRef(),t=a.a.useState(!1),o=Object(l.a)(t,2),i=(o[0],o[1]);a.a.useEffect((function(){i(!0),n.current.setCustomScrollRef()}),[]);var r=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)})),d={textAlign:"center",padding:20};return Object(b.jsxs)("div",{ref:e,style:{height:500,width:"100%",overflowY:"scroll"},children:[Object(b.jsx)("div",{style:d,children:"some random ui"}),Object(b.jsx)("div",{style:d,children:"some random ui"}),Object(b.jsx)(L,{rowComponent:re,data:r,rowHeight:100,scrollRef:e,ref:n}),Object(b.jsx)("div",{style:d,children:"some random ui"}),Object(b.jsx)("div",{style:d,children:"some random ui"})]})}var re=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=n[t];return Object(b.jsx)("div",{style:{textAlign:"center"},children:o},t)})),le='import { FullWindowFixedList, FullWindowVariableList } from "react-recycled-list";\n\nfunction CustomWindowDemo() {\n  const scrollRef = React.useRef();\n  const listRef = React.useRef();\n\n  // Important! ref.current is initially undefined. When ref.current is set you must notify FullWindowFixedList or FullWindowVariableList \n  // You can notify it by rerendering or by calling setCustomScrollRef on the list class\n\n  const [_, setComponentHasMounted] = React.useState(false);\n  React.useEffect(() => {\n    // Once scrollRef.current is set, you must notify the list. You can do it by setState in a useEffect which cause rerendering\n    setComponentHasMounted(true);\n    // Or you can do it by calling the setCustomScrollRef method on the list\n    listRef.current.setCustomScrollRef();\n  }, []);\n\n  const data = Array(1000).fill(null).map((_, index) => `item ${index}`);\n\n  const containerStyle = {\n    height: 500,\n    width: "100%",\n    overflowY: "scroll",\n  };\n\n  const fillerStyle = {\n    textAlign: "center",\n    padding: 20,\n  };\n\n  return (\n    <div ref={ref} style={containerStyle}>\n              <div style={fillerStyle}>some random ui</div>\n              <div style={fillerStyle}>some random ui</div>\n              <FullWindowFixedList\n                    rowComponent={Row}\n                    data={data}\n                    rowHeight={100}\n                    scrollRef={scrollRef}\n                    ref={listRef}\n              />\n              <div style={fillerStyle}>some random ui</div>\n              <div style={fillerStyle}>some random ui</div>\n    </div>\n  );\n}\n\nconst Row = React.memo(function (props: RowProps) {\n  const { data, dataIndex } = props;\n  const value = data[dataIndex];\n  return <div key={dataIndex}>{value}</div>;\n});';function de(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)("div",{style:{width:"100%",height:400,resize:"both",overflow:"auto"},children:Object(b.jsx)(S,{render:function(n){console.log(n);var t=n.width,o=(n.height,t>1200?2:1);return Object(b.jsx)(y,{height:n.height,rowComponent:se,data:e,rowHeight:100,column:o})}})})}var se=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.dataEndIndex,a=e.column,i=n.slice(t,o),r={width:1===a?"100%":"50%",textAlign:"center"};return Object(b.jsx)("div",{style:{height:"100%",width:"100%",display:"flex",alignItems:"center"},children:i.map((function(e){return Object(b.jsx)("div",{style:r,children:e})}))},t)})),ce='import { ResponsiveContainer } from "react-recycled-list";\n\n// Try resizing the list, the column will change on the 1200px break point\n\nfunction ResponsiveContainerDemo() {\n    const data = Array(1000).fill(null).map((_, index) => `item ${index}`);\n  \n    const renderList = (sizeInfo) => {\n      const { width, height } = sizeInfo;\n      const column = width > 1200 ? 2 : 1;\n      return (\n        <FixedList\n                        height={sizeInfo.height}\n                        rowComponent={Row}\n                        data={data}\n                        rowHeight={100}\n                        column={column}\n                />\n      );\n    };\n  \n    const resizableContainerStyle = {\n      width: "100%",\n      height: 400,\n      resize: "both",\n      overflow: "auto"\n    };\n  \n    return (\n      <div style={resizableContainerStyle}>\n                        <ResponsiveContainer render={renderList} />\n            </div>\n    );\n}\n\nconst Row = React.memo(function (props) {\n    const { data, dataIndex: dataStartIndex, dataEndIndex, column } = props;\n    const rowData = data.slice(dataStartIndex, dataEndIndex);\n  \n    const rowStyle = {\n      height: "100%",\n      width: "100%",\n      display: "flex",\n      alignItems: "center",\n    };\n  \n    const columnStyle = {\n      width: column === 1? "100%" : "50%",\n      textAlign: "center",\n    };\n    return (\n      <div key={dataIndex} style={rowStyle}>\n                        {rowData.map((item) => <div style={columnStyle}>{item}</div>)}\n            </div>\n    );\n});';function ue(e){var n=e.render,t=e.debounceResize,o=e.debounceInterval,i=e.serverSideHeight,r=e.scrollContainerRef,d=a.a.useRef(),s=Object(D.a)({refreshMode:t?"debounce":void 0,refreshRate:o||100,targetRef:"scrollContainerRef"in e?r:d}),c=s.width,u=s.height,h=a.a.useState(!1),m=Object(l.a)(h,2),f=m[0],w=m[1];return a.a.useEffect((function(){void 0!==i&&w(!0)})),Object(b.jsxs)(b.Fragment,{children:[n({width:c||0,height:u||!f&&i||0}),Object(b.jsx)("div",{ref:d,style:{position:"fixed",height:"100vh",width:"100vw"}})]})}function he(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)(ue,{render:function(n){console.log(n);var t=n.width,o=n.height,a=t>1200?2:1;return Object(b.jsx)(L,{windowHeight:o,rowComponent:me,data:e,rowHeight:100,column:a})}})}var me=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.dataEndIndex,a=e.column,i=n.slice(t,o),r={width:1===a?"100%":"50%",textAlign:"center"};return Object(b.jsx)("div",{style:{height:"100%",width:"100%",display:"flex",alignItems:"center"},children:i.map((function(e){return Object(b.jsx)("div",{style:r,children:e})}))},t)})),fe='import { FullWindowResponsiveContainer } from "react-recycled-list";\n\n// Try resizing the window, the column will change on the 1200px break point\n\nfunction FullWindowResponsiveContainerDemo() {\n    const data = Array(1000).fill(null).map((_, index) => `item ${index}`);\n  \n    const renderList = (sizeInfo) => {\n      const { width, height } = sizeInfo;\n      const column = width > 1200 ? 2 : 1;\n      return (\n        <FixedList\n                        height={sizeInfo.height}\n                        rowComponent={Row}\n                        data={data}\n                        rowHeight={100}\n                        column={column}\n                />\n      );\n    };\n  \n    return <FullWindowResponsiveContainer render={renderList} />;\n}\n\nconst Row = React.memo(function (props) {\n    const { data, dataIndex: dataStartIndex, dataEndIndex, column } = props;\n    const rowData = data.slice(dataStartIndex, dataEndIndex);\n  \n    const rowStyle = {\n      height: "100%",\n      width: "100%",\n      display: "flex",\n      alignItems: "center",\n    };\n  \n    const columnStyle = {\n      width: column === 1? "100%" : "50%",\n      textAlign: "center",\n    };\n    return (\n      <div key={dataIndex} style={rowStyle}>\n                        {rowData.map((item) => <div style={columnStyle}>{item}</div>)}\n            </div>\n    );\n});',we=t(28),pe=t(15);function ge(e,n){setTimeout((function(){for(var t=[],o=20*(e-1),a=o;a<o+20;a++)t.push("item ".concat(a+1));n(t,e)}),1500)}var ve={data:{1:Array(20).fill(null).map((function(){}))},nextPage:1,isLoading:!1};function xe(){var e=a.a.useState(ve),n=Object(l.a)(e,2),t=n[0],o=n[1],i=function(e,n){var a=Object(pe.a)(Object(pe.a)({},t.data),{},Object(we.a)({},n,e)),i=n+1;i<=5&&(a[i]=[void 0]),o(Object(pe.a)(Object(pe.a)({},t),{},{data:a,isLoading:!1,nextPage:i}))};a.a.useEffect((function(){ge(t.nextPage,i)}),[]);var r=Object.values(t.data).flat();return Object(b.jsx)(y,{height:500,rowComponent:Re,data:r,rowHeight:100,onRenderedRowChange:function(e){e.firstRenderedRowIndex,e.firstRenderedDataIndex,e.lastRenderedRowIndex;var n=e.lastRowIndex;e.lastRenderedDataIndex===n&&!1===t.isLoading&&t.nextPage<=5&&(o(Object(pe.a)(Object(pe.a)({},t),{},{isLoading:!0})),ge(t.nextPage,i))}})}var Re=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=n[t],a=void 0===o?"loading":o;return Object(b.jsx)("div",{children:a},t)})),be='import { FixedList } from "react-recycled-list";\n\n// This is a rather complicated example\n// The key point is to utilize onRenderedRowChange or onVisibleRowChange to load your data\n\nconst numberOfItemPerPage = 20;\n\n// Just a simulation of an API call\nfunction fetchData(page, onSuccess) {\n  setTimeout(() => {\n    const data = [];\n    const startDataIndex = (page - 1) * numberOfItemPerPage;\n    const endDataIndex = startDataIndex + numberOfItemPerPage\n    for (let i = startDataIndex; i < endDataIndex; i++) {\n      data.push(`item ${i + 1}`);\n    }\n    onSuccess(data, page);\n  }, 2000);\n}\n\n// Use a map to store the data (you do not have to do the same, the implementation is up to you)\nconst initialStore = {\n  data: { 1: Array(numberOfItemPerPage).fill(null).map(() => undefined) },\n  nextPage: 0,\n  isLoading: false,\n};\n\nfunction LazyLoadingDemo() {\n  const [store, setStore] = React.useState(initialStore);\n\n  const onFetchDataSuccess = (newData, page) => {\n    const newStoreData = { ...store.data, [page]: newData };\n    // For demo purpose I set the max page to be 5\n    const nextPage = page + 1\n    const hasNextPage = nextPage <= 5;\n    if (hasNextPage) {\n      newStoreData[nextPage] = [undefined];\n    }\n    setStore({ ...store, data: newStoreData, isLoading: false, nextPage: nextPage });\n  };\n\n  React.useEffect(() => {\n    // Initial fetch\n    fetchData(store.nextPage, onFetchDataSuccess)\n  }, [])\n\n  const onRenderedRowChange = (renderInfo) => {\n    const {\n      firstRenderedRowIndex,\n      firstRenderedDataIndex,\n      lastRenderedRowIndex,\n      lastRenderedDataIndex,\n      lastRowIndex,\n    } = renderInfo;\n    // If the last row is rendered (NOT visible yet!) and we are not already loading data, we fetch new data\n    // If you want to fetch data when the last row is visible then use onVisibleRowChange\n    if (lastRenderedRowIndex === lastRowIndex) {\n      if (store.isLoading === false) {\n        setStore({ ...store, isLoading: true });\n        fetchData(store.nextPage, onFetchDataSuccess)\n      }\n    }\n  };\n\n  const listData = Object.values(store.data).flat();\n\n  return (\n    <FixedList\n              height={500}\n              rowComponent={Row}\n              data={listData}\n              rowHeight={100}\n              onRenderedRowChange={onRenderedRowChange}\n        />\n  );\n}\nconst Row = React.memo(function (props: RowProps) {\n  const { data, dataIndex } = props;\n  const value = data[dataIndex];\n  const displayValue = value === undefined ? "loading" : value;\n  return <div key={dataIndex}>{displayValue}</div>;\n})';function Ie(){var e=a.a.useState(Array(20).fill(null).map((function(e,n){return"item ".concat(n+1)}))),n=Object(l.a)(e,2),t=n[0],o=n[1],i=a.a.useState(!1),r=Object(l.a)(i,2),d=r[0],s=r[1];return Object(b.jsx)(y,{height:500,rowComponent:ye,data:t,rowHeight:100,onRenderedRowChange:function(e){e.firstRenderedRowIndex,e.firstRenderedDataIndex,e.lastRenderedRowIndex;var n=e.lastRowIndex;e.lastRenderedDataIndex===n&&!1===d&&(s(!0),setTimeout((function(){for(var e=Object(g.a)(t),n=t.length,a=t.length+20,i=n;i<a;i++)e.push("item ".concat(i+1));o(e),s(!1)}),1e3))}})}var ye=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=n[t],a=void 0===o?"loading":o;return Object(b.jsx)("div",{children:a},t)})),je='import { FixedList } from "react-recycled-list";\nconst numberOfItemPerPage = 20;\n\nfunction LazyLoadingDemo() {\n  const [data, setData] = React.useState( Array(numberOfItemPerPage).fill(null).map((_, index) => `item ${index + 1}`) );\n  const [isLoading, setIsLoading] = React.useState(false);\n\n  const loadData = () => {\n    setTimeout(() => {\n      const newData = [...data];\n      const startIndex = data.length;\n      const endIndex = data.length + numberOfItemPerPage;\n      for (let i = startIndex; i < endIndex; i++) {\n        newData.push(`item ${i + 1}`);\n      }\n      setData(newData);\n      setIsLoading(false);\n    }, 1000);\n  };\n\n  const onRenderedRowChange = (renderInfo) => {\n    const {\n      firstRenderedRowIndex,\n      firstRenderedDataIndex,\n      lastRenderedRowIndex,\n      lastRenderedDataIndex,\n      lastRowIndex,\n    } = renderInfo;\n    // If the last row is rendered (NOT visible yet!) and we are not already loading data, we fetch new data\n    // If you want to fetch data when the last row is visible then use onVisibleRowChange\n    if (lastRenderedDataIndex === lastRowIndex) {\n      if (isLoading === false) {\n        loadData();\n      }\n    }\n  };\n\n  return (\n    <FixedList\n              height={500}\n              rowComponent={Row}\n              data={data}\n              rowHeight={100}\n              onRenderedRowChange={onRenderedRowChange}\n        />\n  );\n}\nconst Row = React.memo(function (props: RowProps) {\n  const { data, dataIndex } = props;\n  const value = data[dataIndex];\n  const displayValue = value === undefined ? "loading" : value;\n  return <div key={dataIndex}>{displayValue}</div>;\n})';function Oe(){var e=Array(1e3).fill(null).map((function(e,n){return n}));return Object(b.jsx)("div",{className:"App",children:Object(b.jsx)(O.b,{height:500,itemSize:100,width:"100%",itemCount:e.length,children:De})})}var De=a.a.memo((function(e){var n=e.index,t=e.style;return Object(b.jsx)("div",{className:"react-recycled-row",style:t,children:"item ".concat(n)})}));var Se='import { FixedList } from "react-recycled-list";\n\nfunction SimpleListDemo() {\n\n  const data = Array(1000).fill(null).map((_, index) => `index ${index}`);\n\n  return <FixedList height={500} rowComponent={Row} data={data} rowHeight={100}/>\n}\n\n// Use React.memo or React pure component to prevent unncessary render\nconst Row = React.memo(function (props) {\n  // the data here is the same data that is passed into the FixedList\n  const { data, dataIndex } = props;\n\n  // Note, the css you see in the demo above is not defined here, check the code sandbox for more\n\n  const value = data[dataIndex];\n  return <div>{value}</div>;\n})';var Le=function(){for(var e={},n=1;n<=10;n++)e[n]={isLoading:!1,hasLoaded:!1,data:Array(10).fill(null).map((function(){}))};return e}();function He(e){return Math.floor(e/10)+1}function Ce(){var e=a.a.useState(Le),n=Object(l.a)(e,2),t=n[0],o=n[1],i=function(e,n){o((function(t){return Object(pe.a)(Object(pe.a)({},t),{},Object(we.a)({},n,{data:e,hasLoaded:!0,isLoading:!1}))}))},r=a.a.useMemo((function(){return Object.values(t).map((function(e){return e.data})).flat()}),[t]);return Object(b.jsx)(y,{height:500,rowComponent:Te,data:r,rowHeight:100,onRenderedRowChange:function(e){var n=e.firstRenderedDataIndex,a=e.lastRenderedDataIndex,r=He(n),l=He(a),d=[r,l];r===l&&d.pop(),d.forEach((function(e){t[e].hasLoaded||t[e].isLoading||(o(Object(pe.a)(Object(pe.a)({},t),{},Object(we.a)({},e,Object(pe.a)(Object(pe.a)({},t[e]),{},{isLoading:!0})))),function(e,n){setTimeout((function(){for(var t=[],o=10*(e-1),a=o;a<o+10;a++)t.push("item ".concat(a+1));n(t,e)}),1e3)}(e,i))}))}})}var Te=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=n[t],a=void 0===o?"loading":o;return Object(b.jsx)("div",{children:a},t)})),Pe='import { FixedList } from "react-recycled-list";\n\n// This is a rather complicated example\n// The key point is to paginate your data, and utilize onRenderedRowChange or onVisibleRowChange to load your data\n\nconst numberOfItemPerPage = 20;\n\nconst numberOfItemPerPage = 10;\nconst numberOfPages = 10;\n// Simulation of an API\nfunction fetchData(page, onSuccess) {\n  setTimeout(() => {\n    const data = [];\n    const startDataIndex = (page - 1) * numberOfItemPerPage;\n    for (\n      let i = startDataIndex;\n      i < startDataIndex + numberOfItemPerPage;\n      i++\n    ) {\n      data.push(`item ${i + 1}`);\n    }\n    onSuccess(data, page);\n  }, 1000);\n}\n\nfunction populateInitialPage() {\n    const page: PageData = {};\n    for (let i = 1; i <= numberOfPages; i++) {\n      page[i] = {\n        isLoading: false,\n        hasLoaded: false,\n        data: Array(numberOfItemPerPage)\n          .fill(null)\n          .map(() => undefined),\n      };\n    }\n    return page;\n}\nconst initialPagedData = populateInitialPage();\n\nfunction getPageFromDataIndex(index: number) {\n    return Math.floor(index / numberOfItemPerPage) + 1;\n}\n  \nfunction DynamicLoadingDemo() {\n    const [pagedData, setPagedData] = React.useState(initialPagedData);\n  \n    const onFetchDataSuccess = (newData, page) => {\n      // Becareful of stale state!\n      setPagedData((pagedData) => {\n        return {\n          ...pagedData,\n          [page]: {\n            data: newData,\n            hasLoaded: true,\n            isLoading: false,\n          },\n        };\n      });\n    };\n  \n    const onRenderedRowChange = (renderInfo) => {\n      const {\n        firstRenderedDataIndex,\n        lastRenderedDataIndex,\n      } = renderInfo;\n  \n      const currentTopPage = getPageFromDataIndex(firstRenderedDataIndex);\n      const currentBottomPage = getPageFromDataIndex(lastRenderedDataIndex);\n      const currentPages = [currentTopPage, currentBottomPage];\n  \n      if (currentTopPage === currentBottomPage) currentPages.pop();\n  \n      currentPages.forEach((page) => {\n        if (!pagedData[page].hasLoaded && !pagedData[page].isLoading) {\n          setPagedData({\n            ...pagedData,\n            [page]: { ...pagedData[page], isLoading: true },\n          });\n          fetchData(page, onFetchDataSuccess);\n        }\n      });\n    };\n    const dataList = Object.values(pagedData).map(({ data }) => data).flat();\n\n    return (\n      <FixedList\n                    height={500}\n                    rowComponent={Row}\n                    data={dataList}\n                    rowHeight={100}\n                    onRenderedRowChange={onRenderedRowChange}\n            />\n    );\n}\nconst Row = React.memo(function (props: RowProps) {\n  const { data, dataIndex } = props;\n  const value = data[dataIndex];\n  const displayValue = value === undefined ? "loading" : value;\n  return <div key={dataIndex}>{displayValue}</div>;\n})';function Ae(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)}));return Object(b.jsx)(y,{height:500,rowComponent:Ne,data:e,rowHeight:100,useScrollingIndicator:!0})}var Ne=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.isScrolling?"scrolling":n[t];return Object(b.jsx)("div",{children:o},t)})),Me='import { FixedList } from "react-recycled-list";\n\n// If your row component is expensive to render, you can consider rendering a lighter component when scrolling\n\nfunction ScrollIndicatorDemo() {\n  const data = Array(1000).fill(null).map((_, index) => `index ${index}`);\n\n  return <FixedList height={500} rowComponent={Row} data={data} rowHeight={100} useScrollingIndicator/>\n}\n\nconst Row = React.memo(function (props: RowProps) {\n    const { data, dataIndex, isScrolling } = props;\n    const value = isScrolling? "scrolling" : data[dataIndex];\n    return <div key={dataIndex}>{value}</div>;\n});',Ee=t(288);function Fe(){var e=Array(1e3).fill(null).map((function(e,n){return"item ".concat(n)})),n=a.a.useRef();return Object(b.jsxs)("div",{children:[Object(b.jsxs)("div",{style:{display:"flex",justifyContent:"space-evenly",alignItems:"center",padding:10},children:[Object(b.jsx)(Ee.a,{variant:"contained",color:"secondary",style:{textTransform:"none"},onClick:function(){var e;return null===(e=n.current)||void 0===e?void 0:e.scrollTo(350)},children:"Scroll to scrollTop 350"}),Object(b.jsx)(Ee.a,{variant:"contained",color:"secondary",style:{textTransform:"none"},onClick:function(){var e;return null===(e=n.current)||void 0===e?void 0:e.scrollToRow(9)},children:"Scroll to 10th row"}),Object(b.jsx)(Ee.a,{variant:"contained",color:"secondary",style:{textTransform:"none"},onClick:function(){var e;return null===(e=n.current)||void 0===e?void 0:e.scrollToDataIndex(86)},children:"Scroll to 87th data"})]}),Object(b.jsx)(y,{height:300,rowComponent:Ve,data:e,rowHeight:100,column:4,ref:n})]})}var Ve=a.a.memo((function(e){var n=e.data,t=e.dataIndex,o=e.dataEndIndex,a=n.slice(t,o),i={width:"25%",textAlign:"center"};return Object(b.jsx)("div",{style:{height:"100%",width:"100%",display:"flex",alignItems:"center"},children:a.map((function(e){return Object(b.jsx)("div",{style:i,children:e})}))},t)})),ke='import { FixedList } from "react-recycled-list";\n\nfunction ScrollToDemo() {\n    const data = Array(1000).fill(null).map((_, index) => `item ${index}`);\n    const ref = React.useRef();\n    return (\n        <div>\n                        <button onClick={() => ref.current?.scrollTo(350)} />\n                        <button onClick={() => ref.current?.scrollToRow(9)} />\n                        <button onClick={() => ref.current?.scrollToDataIndex(86)} />\n                        <FixedList height={300} rowComponent={Row} data={data} rowHeight={100} column={4} ref={ref}/>\n                </div>\n    )\n}\n\nconst Row = React.memo(function (props) {\n    const { data, dataIndex: dataStartIndex, dataEndIndex } = props;\n    const rowData = data.slice(dataStartIndex, dataEndIndex);\n    const rowStyle = {\n        height: "100%",\n        width: "100%",\n        display: "flex",\n        alignItems: "center",\n    };\n    const columnStyle = {\n        width: "25%",\n        textAlign: "center",\n    };\n    return (\n        <div key={dataIndex} style={rowStyle}>\n                            {rowData.map((item) => <div style={columnStyle} key={item}>{item}</div>)}\n                 </div>\n    )\n});';function We(){var e=Object(H.f)().pathname;return Object(b.jsx)("div",{children:Object(b.jsxs)(C.a,{variant:"permanent",anchor:"left",children:[Object(b.jsx)(T.a,{variant:"h6",className:"site-title",children:"React recycled list"}),Object(b.jsx)(P.a,{}),Object(b.jsxs)(A.a,{children:[Object(b.jsx)(N.a,{children:Object(b.jsx)(M.a,{primary:"Introduction",className:"first-level"})}),Object(b.jsx)(N.a,{button:!0,className:"second-level",component:E.b,to:"/",children:Object(b.jsx)(M.a,{primary:"Why use React recycled list"})}),Object(b.jsx)(N.a,{children:Object(b.jsx)(M.a,{primary:"Examples",className:"first-level"})}),ze.map((function(n){var t=n.label,o=n.route;return Object(b.jsx)(N.a,{button:!0,className:"second-level",component:E.b,to:o,selected:e===o,children:Object(b.jsx)(M.a,{primary:t})},t)}))]}),Object(b.jsx)(P.a,{}),Object(b.jsxs)(A.a,{children:[Object(b.jsx)(N.a,{children:Object(b.jsx)(M.a,{primary:"Components",className:"first-level"})}),Be.map((function(n){var t=n.label,o=n.route;return Object(b.jsx)(N.a,{button:!0,className:"second-level",component:E.b,to:o,selected:e===o,children:Object(b.jsx)(M.a,{primary:t})},t)}))]})]})})}var ze=[{label:"Simple List",route:"/simple-list",component:function(){return Object(b.jsx)(k,{code:_,Demo:z})}},{label:"VS React window",route:"/react-window",component:function(){return Object(b.jsx)(k,{code:Se,Demo:Oe})}},{label:"Simple Grid",route:"/simple-grid",component:function(){return Object(b.jsx)(k,{code:U,Demo:$})}},{label:"Variable row height",route:"/variable-row-height",component:function(){return Object(b.jsx)(k,{code:J,Demo:q})}},{label:"Variable column",route:"/variable-column",component:function(){return Object(b.jsx)(k,{code:X,Demo:K})}},{label:"Variable row height and column ",route:"/variable-height-column",component:function(){return Object(b.jsx)(k,{code:ae,Demo:te})}},{label:"Full window",route:"/full-window",component:function(){return Object(b.jsxs)(b.Fragment,{children:[Object(b.jsx)("div",{className:"code-section half-section",children:Object(b.jsx)("div",{className:"code-wrapper",children:Object(b.jsx)(V.a,{language:"js",children:ne})})}),Object(b.jsx)("div",{className:"demo-section half-section",children:Object(b.jsx)(Z,{})})]})}},{label:"Custom window",route:"/custom-window",component:function(){return Object(b.jsx)(k,{code:le,Demo:ie})}},{label:"Responsive List/Grid",route:"/responsive-list/grid",component:function(){return Object(b.jsx)(k,{code:ce,Demo:de})}},{label:"Responsive window",route:"/responsive-window",component:function(){return Object(b.jsxs)(b.Fragment,{children:[Object(b.jsx)("div",{className:"code-section half-section",children:Object(b.jsx)("div",{className:"code-wrapper",children:Object(b.jsx)(V.a,{language:"js",children:fe})})}),Object(b.jsx)("div",{className:"demo-section half-section",children:Object(b.jsx)(he,{})})]})}},{label:"Simple Infinite loading",route:"/lazy-loading-simple",component:function(){return Object(b.jsx)(k,{code:je,Demo:Ie})}},{label:"Advanced Infinite loading",route:"/lazy-loading-advance",component:function(){return Object(b.jsx)(k,{code:be,Demo:xe})}},{label:"Dynamic loading",route:"/dynamic-loading",component:function(){return Object(b.jsx)(k,{code:Pe,Demo:Ce})}},{label:"Scroll indicator",route:"/scroll-indicator",component:function(){return Object(b.jsx)(k,{code:Me,Demo:Ae})}},{label:"Scroll to",route:"/scroll-to",component:function(){return Object(b.jsx)(k,{code:ke,Demo:Fe})}},{label:"Styling",route:"/styling"},{label:"Server side rendering",route:"/styling"}],Be=[{label:"FixedSizeList",route:"/fixedsizelist"},{label:"VariableSizeList",route:"/variablesizelist"},{label:"FixedSizeWindowList",route:"/fixedsizewindowlist"},{label:"VariableSizeWindowList",route:"/variablesizewindowList"},{label:"ResponsiveContainer",route:"/rResponsivecontainer"},{label:"ResponsiveWindowContainer",route:"/responsiveWindowcontainer"}];Array(6).fill(null).map((function(e,n){return n}));var _e=function(){return a.a.useRef(),Object(b.jsxs)("div",{className:"root-content",children:[Object(b.jsx)(We,{}),Object(b.jsx)("main",{children:Object(b.jsx)(H.c,{children:ze.map((function(e){e.label;var n=e.route,t=e.component;return Object(b.jsx)(H.a,{path:n,children:t&&t})}))})})]})},$e=function(e){e&&e instanceof Function&&t.e(3).then(t.bind(null,298)).then((function(n){var t=n.getCLS,o=n.getFID,a=n.getFCP,i=n.getLCP,r=n.getTTFB;t(e),o(e),a(e),i(e),r(e)}))};r.a.render(Object(b.jsx)(a.a.StrictMode,{children:Object(b.jsx)(E.a,{children:Object(b.jsx)(_e,{})})}),document.getElementById("root")),$e()},57:function(e,n,t){},72:function(e,n,t){},73:function(e,n,t){}},[[267,1,2]]]);
//# sourceMappingURL=main.9524ebe7.chunk.js.map